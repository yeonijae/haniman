import React, { useState, useMemo, useEffect } from 'react';
import Header, { ModalType, ViewType } from './components/Header';
import ReservationStatus from './components/ReservationStatus';
import ConsultationStatus from './components/ConsultationStatus';
import WaitingList from './components/WaitingList';
import TreatmentRoomStatus from './components/TreatmentRoomStatus';
import PaymentStatus from './components/PaymentStatus';
import Modal from './components/Modal';
import { Patient, PatientStatus, ReservationsState, Reservation, Payment, CompletedPayment, PaymentMethod, TreatmentDetailItem, MedicalStaff, Staff, UncoveredCategories, ConsultationRoom, ActingQueueState, Acting, ActingType, TreatmentRoom, RoomStatus, DefaultTreatment, SessionTreatment, User } from './types';
import { CONSULTATION_WAITING_LIST, TREATMENT_WAITING_LIST, ALL_PATIENTS, PAYMENTS_WAITING, MEDICAL_STAFF_LIST, STAFF_LIST, UNCOVERED_CATEGORIES_DATA, CONSULTATION_ROOMS, INITIAL_TREATMENT_ROOMS, DOCTORS, USERS } from './constants';
import NewPatientForm, { NewPatientData } from './components/NewPatientForm';
import { NewReservationData } from './components/NewReservationForm';
import ReservationModal from './components/ReservationModal';
import PatientSearch from './components/PatientSearch';
import PaymentModal from './components/PaymentModal';
import DailyPaymentSummary from './components/DailyPaymentSummary';
import Settings, { BulkPatientData } from './components/Settings';
import TreatmentView from './components/TreatmentView';
import ActingManagementView from './components/ActingManagementView';
import LoginScreen from './components/LoginScreen';
// Supabase API í†µí•©
import * as api from './lib/api';
import { supabase } from './lib/supabaseClient';

const findAvailableSlot = (
    currentDateKey: string, 
    currentTime: string, 
    actingNeeded: number, 
    reservationState: ReservationsState,
    doctor: string,
    ignoreReservationId?: string
): { date: string, time: string, acting: number }[] => {
    let remainingActing = actingNeeded;
    const slots = [];
    let [hour, minute] = currentTime.split(':').map(Number);
    
    const getDateFromKey = (key: string) => {
        const [y, m, d] = key.split('-').map(Number);
        return new Date(y, m - 1, d);
    }

    let currentDay = getDateFromKey(currentDateKey);

    while (remainingActing > 0) {
        const timeKey = `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
        
        const year = currentDay.getFullYear();
        const month = String(currentDay.getMonth() + 1).padStart(2, '0');
        const day = String(currentDay.getDate()).padStart(2, '0');
        const dayKey = `${year}-${month}-${day}`;

        let existingReservations = reservationState[dayKey]?.[doctor]?.[timeKey] || [];
        if(ignoreReservationId) {
            existingReservations = existingReservations.filter(r => r.id !== ignoreReservationId);
        }
        
        const usedActing = existingReservations.reduce((sum, r) => sum + r.slotActing, 0);
        const availableActing = 6 - usedActing;

        const actingToBook = Math.min(remainingActing, availableActing);
        
        if (actingToBook > 0) {
            slots.push({ date: dayKey, time: timeKey, acting: actingToBook });
            remainingActing -= actingToBook;
        }

        // Move to next 30-min slot
        minute += 30;
        if (minute >= 60) {
            hour++;
            minute = 0;
        }
        if (hour >= 20) { // End of day
            hour = 9;
            minute = 30;
            currentDay.setDate(currentDay.getDate() + 1); // Move to next day
        }
    }
    return slots;
};

// The type for PaymentItem from the modal
type PaymentItem = { id: number; method: PaymentMethod; amount: string; };

interface BulkAddFailure {
    name: string;
    chartNumber?: string;
    reason: string;
}

const App: React.FC = () => {
  const [currentUser, setCurrentUser] = useState<User | null>(null);
  const [currentView, setCurrentView] = useState<ViewType>('dashboard');
  const [modalType, setModalType] = useState<ModalType | null>(null);
  const [modalTitle, setModalTitle] = useState<string>('');
  const [isModalWide, setIsModalWide] = useState<boolean>(false);
  const [editingReservation, setEditingReservation] = useState<Reservation | null>(null);
  const [selectedPayment, setSelectedPayment] = useState<Payment | null>(null);
  const [bulkAddResult, setBulkAddResult] = useState<{ new: number; updated: number; failures: BulkAddFailure[] } | null>(null);
  const [patientIdToDelete, setPatientIdToDelete] = useState<number | null>(null);
  const [patientForNewReservation, setPatientForNewReservation] = useState<Patient | null>(null);
  const [actingToEdit, setActingToEdit] = useState<{ doctorId: string; acting: Acting } | null>(null);


  const [allPatients, setAllPatients] = useState<Patient[]>([]);
  const [consultationWaitingList, setConsultationWaitingList] = useState<Patient[]>([]);
  const [treatmentWaitingList, setTreatmentWaitingList] = useState<Patient[]>([]);
  const [reservations, setReservations] = useState<ReservationsState>({});
  const [paymentsWaiting, setPaymentsWaiting] = useState<Payment[]>([]);
  const [completedPayments, setCompletedPayments] = useState<CompletedPayment[]>([]);
  const [medicalStaff, setMedicalStaff] = useState<MedicalStaff[]>([]);
  const [staff, setStaff] = useState<Staff[]>([]);
  const [uncoveredCategories, setUncoveredCategories] = useState<UncoveredCategories>({});
  const [consultationRooms, setConsultationRooms] = useState<ConsultationRoom[]>(CONSULTATION_ROOMS);
  const [treatmentRooms, setTreatmentRooms] = useState<TreatmentRoom[]>([]);
  const [actingQueues, setActingQueues] = useState<ActingQueueState>({
    'ê¹€ì›ì¥': [
      { id: 'act-temp-1', patientId: 9, patientName: 'ë°•ì„œì¤€', type: 'ì¹¨', duration: 15, source: 'manual' },
      { id: 'act-temp-2', patientId: 10, patientName: 'í•œì§€ë¯¼', type: 'ì¶”ë‚˜', duration: 20, source: 'manual' },
      { id: 'act-temp-3', patientId: 2, patientName: 'ì´ì„œì—°', type: 'ì•½ìƒë‹´', duration: 25, source: 'manual' },
      { id: 'act-temp-9', patientId: 1, patientName: 'ê¹€ë¯¼ì¤€', type: 'ì¹¨', duration: 15, source: 'manual' },
    ],
    'ê°•ì›ì¥': [
        { id: 'act-temp-4', patientId: 8, patientName: 'ì†¡ì˜ˆë‚˜', type: 'ì•½ìƒë‹´', duration: 30, source: 'manual' },
        { id: 'act-temp-5', patientId: 6, patientName: 'ìœ¤ì±„ì›', type: 'ì´ˆì§„', duration: 30, source: 'manual' },
        { id: 'act-temp-10', patientId: 5, patientName: 'ì •ì‹œìš°', type: 'í–¥ê¸°', duration: 5, source: 'manual' },
        { id: 'act-temp-11', patientId: 7, patientName: 'ê°•ì§€í˜¸', type: 'ìŠµë¶€', duration: 10, source: 'manual' },
    ],
    'ì„ì›ì¥': [
        { id: 'act-temp-6', patientId: 4, patientName: 'ìµœì§€ìš°', type: 'ì´ˆìŒíŒŒ', duration: 10, source: 'manual' },
        { id: 'act-temp-7', patientId: 3, patientName: 'ë°•í•˜ì¤€', type: 'ì¹¨', duration: 15, source: 'manual' },
        { id: 'act-temp-8', patientId: 11, patientName: 'ì¡°ì€ì„œ', type: 'ê¸°íƒ€', duration: 5, source: 'manual' },
        { id: 'act-temp-12', patientId: 12, patientName: 'ì„ë„ìœ¤', type: 'ëŒ€ê¸°', duration: 0, source: 'manual' },
    ],
    'ì „ì›ì¥': [
        { id: 'act-temp-13', patientId: 13, patientName: 'ì‹ ìœ ì¤€', type: 'ì¹¨', duration: 15, source: 'manual' },
        { id: 'act-temp-14', patientId: 14, patientName: 'ê¹€ì² ìˆ˜', type: 'ì¶”ë‚˜', duration: 20, source: 'manual' },
        { id: 'act-temp-15', patientId: 15, patientName: 'ë°•ì˜í¬', type: 'ì´ˆìŒíŒŒ', duration: 10, source: 'manual' },
    ],
  });

  // Effect for loading initial data from Supabase
  useEffect(() => {
    if (!currentUser) return; // ë¡œê·¸ì¸ ì „ì—ëŠ” ë¡œë“œí•˜ì§€ ì•ŠìŒ

    const loadInitialData = async () => {
      try {
        console.log('ğŸ“¥ Supabaseì—ì„œ ë°ì´í„° ë¡œë“œ ì¤‘...');

        // í™˜ì ë°ì´í„° ë¡œë“œ
        const patients = await api.fetchPatients();
        console.log(`âœ… ${patients.length}ëª…ì˜ í™˜ì ë°ì´í„° ë¡œë“œ ì™„ë£Œ`);
        setAllPatients(patients);

        // ê° í™˜ìì˜ ê¸°ë³¸ ì¹˜ë£Œ ë¡œë“œ
        for (const patient of patients) {
          const defaultTreatments = await api.fetchPatientDefaultTreatments(patient.id);
          if (defaultTreatments.length > 0) {
            setAllPatients(prev => prev.map(p =>
              p.id === patient.id ? { ...p, defaultTreatments } : p
            ));
          }
        }

        // ì˜ë£Œì§„ ë°ì´í„° ë¡œë“œ
        const medicalStaffData = await api.fetchMedicalStaff();
        console.log(`âœ… ${medicalStaffData.length}ëª…ì˜ ì˜ë£Œì§„ ë°ì´í„° ë¡œë“œ ì™„ë£Œ`);
        setMedicalStaff(medicalStaffData);

        // ìŠ¤íƒœí”„ ë°ì´í„° ë¡œë“œ
        const staffData = await api.fetchStaff();
        console.log(`âœ… ${staffData.length}ëª…ì˜ ìŠ¤íƒœí”„ ë°ì´í„° ë¡œë“œ ì™„ë£Œ`);
        setStaff(staffData);

        // ë¹„ê¸‰ì—¬ ì¹´í…Œê³ ë¦¬ ë°ì´í„° ë¡œë“œ
        const categoriesData = await api.fetchUncoveredCategories();
        console.log(`âœ… ë¹„ê¸‰ì—¬ ì¹´í…Œê³ ë¦¬ ë°ì´í„° ë¡œë“œ ì™„ë£Œ`);
        setUncoveredCategories(categoriesData);

        // ì¹˜ë£Œì‹¤ ë°ì´í„° ë¡œë“œ
        const roomsData = await api.fetchTreatmentRooms();
        console.log(`âœ… ${roomsData.length}ê°œì˜ ì¹˜ë£Œì‹¤ ë°ì´í„° ë¡œë“œ ì™„ë£Œ`);
        setTreatmentRooms(roomsData);

      } catch (error) {
        console.error('âŒ ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜:', error);
        alert('ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. Supabase ì„¤ì •ì„ í™•ì¸í•´ì£¼ì„¸ìš”.');
      }
    };

    loadInitialData();
  }, [currentUser]);

  // ê²°ì œ ë°ì´í„° ë¡œë“œ
  useEffect(() => {
    if (!currentUser) return;

    const loadPaymentData = async () => {
      try {
        console.log('ğŸ“¥ Supabaseì—ì„œ ê²°ì œ ë°ì´í„° ë¡œë“œ ì¤‘...');

        // ë¯¸ì™„ë£Œ ê²°ì œ ë¡œë“œ
        const pendingPayments = await api.fetchPendingPayments();
        console.log(`âœ… ${pendingPayments.length}ê°œì˜ ë¯¸ì™„ë£Œ ê²°ì œ ë¡œë“œ ì™„ë£Œ`);
        setPaymentsWaiting(pendingPayments);

        // ì™„ë£Œëœ ê²°ì œ ë¡œë“œ (ìµœê·¼ 100ê°œë§Œ)
        const completed = await api.fetchCompletedPayments(100);
        console.log(`âœ… ${completed.length}ê°œì˜ ì™„ë£Œ ê²°ì œ ë¡œë“œ ì™„ë£Œ`);

        // completedPayments í˜•ì‹ìœ¼ë¡œ ë³€í™˜
        const formattedCompleted = completed.map(payment => ({
          paymentId: payment.id,
          patientId: payment.patientId,
          patientName: payment.patientName,
          patientChartNumber: payment.patientChartNumber,
          totalAmount: payment.totalAmount || 0,
          paidAmount: payment.paidAmount || 0,
          remainingAmount: payment.remainingAmount || 0,
          details: payment.details || 'ì§„ë£Œë¹„',
          paymentMethods: payment.paymentMethods || [],
          completedDate: payment.completedAt ? new Date(payment.completedAt).toLocaleDateString('ko-KR') : '',
          treatmentItems: payment.treatmentItems || []
        }));
        setCompletedPayments(formattedCompleted);

      } catch (error) {
        console.error('âŒ ê²°ì œ ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜:', error);
        alert('ê²°ì œ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
      }
    };

    loadPaymentData();
  }, [currentUser]);

  // ì˜ˆì•½ ë°ì´í„° ë¡œë“œ
  useEffect(() => {
    if (!currentUser) return;

    const loadReservationData = async () => {
      try {
        console.log('ğŸ“¥ Supabaseì—ì„œ ì˜ˆì•½ ë°ì´í„° ë¡œë“œ ì¤‘...');

        // ëª¨ë“  ì˜ˆì•½ ë¡œë“œ (í–¥í›„ 30ì¼ì¹˜)
        const today = new Date();
        const futureDate = new Date();
        futureDate.setDate(today.getDate() + 30);

        const allReservations = await api.fetchReservations({
          startDate: today.toISOString().split('T')[0],
          endDate: futureDate.toISOString().split('T')[0],
        });

        console.log(`âœ… ${allReservations.length}ê°œì˜ ì˜ˆì•½ ë¡œë“œ ì™„ë£Œ`);

        // ê° ì˜ˆì•½ì˜ ì¹˜ë£Œ í•­ëª© ë¡œë“œ ë° ë¡œì»¬ í˜•ì‹ìœ¼ë¡œ ë³€í™˜
        const reservationsNested: { [date: string]: { [doctor: string]: { [time: string]: Reservation[] } } } = {};

        for (const res of allReservations) {
          const treatments = await api.fetchReservationTreatments(res.id);

          const year = res.reservation_date.substring(0, 4);
          const month = res.reservation_date.substring(5, 7);
          const day = res.reservation_date.substring(8, 10);
          const dateKey = `${year}-${month}-${day}`;
          const timeKey = res.reservation_time;

          const patient = allPatients.find(p => p.id === res.patient_id);

          // ì˜ˆì•½ì„ ìŠ¬ë¡¯ë³„ë¡œ ë¶„í• í•˜ì—¬ UI í˜•ì‹ì— ë§ê²Œ ë³€í™˜
          const totalActing = treatments.reduce((sum, t) => sum + t.acting, 0);
          const slots = findAvailableSlot(dateKey, timeKey, totalActing, reservationsNested, res.doctor);

          slots.forEach((slot, index) => {
            const reservation: Reservation = {
              id: res.id,
              partId: `${res.id}-${slot.date}-${slot.time}`,
              patientId: res.patient_id,
              patientName: patient?.name || 'ì•Œ ìˆ˜ ì—†ìŒ',
              patientChartNumber: patient?.chartNumber || '',
              doctor: res.doctor,
              date: slot.date,
              time: slot.time,
              treatments,
              slotActing: slot.acting,
              isContinuation: index > 0,
              memo: res.memo || '',
              status: res.status || 'confirmed',
            };

            if (!reservationsNested[slot.date]) reservationsNested[slot.date] = {};
            if (!reservationsNested[slot.date][res.doctor]) reservationsNested[slot.date][res.doctor] = {};
            if (!reservationsNested[slot.date][res.doctor][slot.time]) reservationsNested[slot.date][res.doctor][slot.time] = [];

            reservationsNested[slot.date][res.doctor][slot.time].push(reservation);
          });
        }

        setReservations(reservationsNested);

      } catch (error) {
        console.error('âŒ ì˜ˆì•½ ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜:', error);
        alert('ì˜ˆì•½ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
      }
    };

    loadReservationData();
  }, [currentUser, allPatients]);

  // Supabase Realtime ì‹¤ì‹œê°„ êµ¬ë…
  useEffect(() => {
    if (!currentUser) return;

    console.log('ğŸ”„ Supabase Realtime êµ¬ë… ì‹œì‘...');

    // í™˜ì ë°ì´í„° ì‹¤ì‹œê°„ êµ¬ë…
    const patientsSubscription = supabase
      .channel('patients-changes')
      .on('postgres_changes',
        { event: '*', schema: 'public', table: 'patients' },
        async (payload) => {
          console.log('ğŸ“¨ í™˜ì ë°ì´í„° ë³€ê²½ ê°ì§€:', payload);

          if (payload.eventType === 'INSERT') {
            const newPatient = payload.new as any;
            const treatments = await api.fetchPatientDefaultTreatments(newPatient.id);
            setAllPatients(prev => [...prev, { ...newPatient, defaultTreatments: treatments }]);
          } else if (payload.eventType === 'UPDATE') {
            const updatedPatient = payload.new as any;
            const treatments = await api.fetchPatientDefaultTreatments(updatedPatient.id);
            setAllPatients(prev => prev.map(p =>
              p.id === updatedPatient.id ? { ...updatedPatient, defaultTreatments: treatments } : p
            ));
          } else if (payload.eventType === 'DELETE') {
            const deletedId = payload.old.id;
            setAllPatients(prev => prev.filter(p => p.id !== deletedId));
          }
        }
      )
      .subscribe();

    // ê²°ì œ ë°ì´í„° ì‹¤ì‹œê°„ êµ¬ë…
    const paymentsSubscription = supabase
      .channel('payments-changes')
      .on('postgres_changes',
        { event: '*', schema: 'public', table: 'payments' },
        (payload) => {
          console.log('ğŸ“¨ ê²°ì œ ë°ì´í„° ë³€ê²½ ê°ì§€:', payload);

          if (payload.eventType === 'INSERT') {
            const newPayment = payload.new as any;
            if (!newPayment.isPaid) {
              setPaymentsWaiting(prev => [...prev, newPayment]);
            }
          } else if (payload.eventType === 'UPDATE') {
            const updatedPayment = payload.new as any;

            if (updatedPayment.isPaid) {
              // ì™„ë£Œëœ ê²°ì œë¡œ ì´ë™
              setPaymentsWaiting(prev => prev.filter(p => p.id !== updatedPayment.id));

              const formattedCompleted = {
                paymentId: updatedPayment.id,
                patientId: updatedPayment.patientId,
                patientName: updatedPayment.patientName,
                patientChartNumber: updatedPayment.patientChartNumber,
                totalAmount: updatedPayment.totalAmount || 0,
                paidAmount: updatedPayment.paidAmount || 0,
                remainingAmount: updatedPayment.remainingAmount || 0,
                details: updatedPayment.details || 'ì§„ë£Œë¹„',
                paymentMethods: updatedPayment.paymentMethods || [],
                completedDate: updatedPayment.completedAt ? new Date(updatedPayment.completedAt).toLocaleDateString('ko-KR') : '',
                treatmentItems: updatedPayment.treatmentItems || []
              };
              setCompletedPayments(prev => [formattedCompleted, ...prev]);
            } else {
              // ë¯¸ì™„ë£Œ ê²°ì œ ì—…ë°ì´íŠ¸
              setPaymentsWaiting(prev => prev.map(p =>
                p.id === updatedPayment.id ? updatedPayment : p
              ));
            }
          } else if (payload.eventType === 'DELETE') {
            const deletedId = payload.old.id;
            setPaymentsWaiting(prev => prev.filter(p => p.id !== deletedId));
          }
        }
      )
      .subscribe();

    // ì˜ˆì•½ ë°ì´í„° ì‹¤ì‹œê°„ êµ¬ë…
    const reservationsSubscription = supabase
      .channel('reservations-changes')
      .on('postgres_changes',
        { event: '*', schema: 'public', table: 'reservations' },
        async (payload) => {
          console.log('ğŸ“¨ ì˜ˆì•½ ë°ì´í„° ë³€ê²½ ê°ì§€:', payload);

          // ì˜ˆì•½ ë°ì´í„°ê°€ ë³€ê²½ë˜ë©´ ì „ì²´ ì˜ˆì•½ ëª©ë¡ ë‹¤ì‹œ ë¡œë“œ
          // (ì˜ˆì•½ì€ ë³µì¡í•œ ì¤‘ì²© êµ¬ì¡°ì´ë¯€ë¡œ ì „ì²´ ë¡œë“œê°€ ë” ì•ˆì „í•¨)
          try {
            const today = new Date();
            const futureDate = new Date();
            futureDate.setDate(today.getDate() + 30);

            const allReservations = await api.fetchReservations({
              startDate: today.toISOString().split('T')[0],
              endDate: futureDate.toISOString().split('T')[0],
            });

            const reservationsNested: { [date: string]: { [doctor: string]: { [time: string]: Reservation[] } } } = {};

            for (const res of allReservations) {
              const treatments = await api.fetchReservationTreatments(res.id);
              const year = res.reservation_date.substring(0, 4);
              const month = res.reservation_date.substring(5, 7);
              const day = res.reservation_date.substring(8, 10);
              const dateKey = `${year}-${month}-${day}`;
              const timeKey = res.reservation_time;

              const patient = allPatients.find(p => p.id === res.patient_id);
              const totalActing = treatments.reduce((sum, t) => sum + t.acting, 0);
              const slots = findAvailableSlot(dateKey, timeKey, totalActing, reservationsNested, res.doctor);

              slots.forEach((slot, index) => {
                const reservation: Reservation = {
                  id: res.id,
                  partId: `${res.id}-${slot.date}-${slot.time}`,
                  patientId: res.patient_id,
                  patientName: patient?.name || 'ì•Œ ìˆ˜ ì—†ìŒ',
                  patientChartNumber: patient?.chartNumber || '',
                  doctor: res.doctor,
                  date: slot.date,
                  time: slot.time,
                  treatments,
                  slotActing: slot.acting,
                  isContinuation: index > 0,
                  memo: res.memo || '',
                  status: res.status || 'confirmed',
                };

                if (!reservationsNested[slot.date]) reservationsNested[slot.date] = {};
                if (!reservationsNested[slot.date][res.doctor]) reservationsNested[slot.date][res.doctor] = {};
                if (!reservationsNested[slot.date][res.doctor][slot.time]) reservationsNested[slot.date][res.doctor][slot.time] = [];

                reservationsNested[slot.date][res.doctor][slot.time].push(reservation);
              });
            }

            setReservations(reservationsNested);
          } catch (error) {
            console.error('âŒ ì‹¤ì‹œê°„ ì˜ˆì•½ ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜:', error);
          }
        }
      )
      .subscribe();

    // ì¹˜ë£Œì‹¤ ë°ì´í„° ì‹¤ì‹œê°„ êµ¬ë…
    const treatmentRoomsSubscription = supabase
      .channel('treatment-rooms-changes')
      .on('postgres_changes',
        { event: '*', schema: 'public', table: 'treatment_rooms' },
        async (payload) => {
          console.log('ğŸ“¨ ì¹˜ë£Œì‹¤ ë°ì´í„° ë³€ê²½ ê°ì§€:', payload);

          // ì¹˜ë£Œì‹¤ ë°ì´í„°ê°€ ë³€ê²½ë˜ë©´ ì „ì²´ ì¹˜ë£Œì‹¤ ëª©ë¡ ë‹¤ì‹œ ë¡œë“œ
          try {
            const roomsData = await api.fetchTreatmentRooms();
            setTreatmentRooms(roomsData);
          } catch (error) {
            console.error('âŒ ì‹¤ì‹œê°„ ì¹˜ë£Œì‹¤ ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜:', error);
          }
        }
      )
      .subscribe();

    console.log('âœ… Supabase Realtime êµ¬ë… ì™„ë£Œ');

    // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ êµ¬ë… í•´ì œ
    return () => {
      console.log('ğŸ”Œ Supabase Realtime êµ¬ë… í•´ì œ...');
      supabase.removeChannel(patientsSubscription);
      supabase.removeChannel(paymentsSubscription);
      supabase.removeChannel(reservationsSubscription);
      supabase.removeChannel(treatmentRoomsSubscription);
    };
  }, [currentUser, allPatients]);

  // Effect for managing treatment timers
  useEffect(() => {
    const timer = setInterval(() => {
        setTreatmentRooms(currentRooms => {
            let hasChanged = false;
            const updatedRooms = currentRooms.map(room => {
                if (room.status !== RoomStatus.IN_USE) return room;

                const newTreatments = room.sessionTreatments.map(tx => {
                    if (tx.status === 'running' && tx.startTime) {
                        const elapsed = (Date.now() - new Date(tx.startTime).getTime()) / 1000 + tx.elapsedSeconds;
                        if (elapsed >= tx.duration * 60) {
                            hasChanged = true;
                            // Don't auto-complete, just let timer show "ì™„ë£Œ"
                            // return { ...tx, status: 'completed' as const };
                        }
                    }
                    return tx;
                });

                if (hasChanged) {
                    return { ...room, sessionTreatments: newTreatments };
                }
                return room;
            });

            return hasChanged ? updatedRooms : currentRooms;
        });
    }, 1000); // Update every second for live timers

    return () => clearInterval(timer);
  }, []);


  const activePatients = useMemo(() => allPatients.filter(p => !p.deletionDate), [allPatients]);
  const deletedPatients = useMemo(() => allPatients.filter(p => !!p.deletionDate), [allPatients]);

  const patientToDeleteInfo = useMemo(() => {
    if (!patientIdToDelete) return null;
    return allPatients.find(p => p.id === patientIdToDelete);
  }, [patientIdToDelete, allPatients]);


  const openModal = (type: ModalType, title: string, wide?: boolean) => {
    setModalType(type);
    setModalTitle(title);
    setIsModalWide(wide || false);
  };

  const closeModal = () => {
    setModalType(null);
    setModalTitle('');
    setIsModalWide(false);
    setEditingReservation(null);
    setSelectedPayment(null);
    setPatientForNewReservation(null);
    setActingToEdit(null);
  };
  
  const handleEditReservation = (reservationToEdit: Reservation) => {
    setEditingReservation(reservationToEdit);
    openModal('reservation', 'ì˜ˆì•½ ìˆ˜ì •', false);
  };

  const addNewReservation = async (data: NewReservationData) => {
    const { patient, doctor, date, time, treatments, memo } = data;

    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const dateKey = `${year}-${month}-${day}`;

    const totalActing = treatments.reduce((sum, t) => sum + t.acting, 0);

    const slots = findAvailableSlot(dateKey, time, totalActing, reservations, doctor);

    let reservationId: string;

    try {
      // Supabaseì— ì˜ˆì•½ ì €ì¥ (UUID ìë™ ìƒì„±ë¨)
      reservationId = await api.createReservation({
        patientId: patient.id,
        doctor,
        reservationDate: dateKey,
        reservationTime: time,
        status: 'confirmed',
        memo: memo || '',
      });

      // ì¹˜ë£Œ í•­ëª© ì €ì¥
      await api.addReservationTreatments(reservationId, treatments);

      console.log('âœ… ì˜ˆì•½ Supabase ì €ì¥ ì™„ë£Œ, ID:', reservationId);
    } catch (error) {
      console.error('âŒ ì˜ˆì•½ ì €ì¥ ì˜¤ë¥˜:', error);
      alert('ì˜ˆì•½ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
      return;
    }

    // ë¡œì»¬ ìƒíƒœ ì—…ë°ì´íŠ¸
    setReservations(prev => {
        const newReservations = JSON.parse(JSON.stringify(prev));

        slots.forEach((slot, index) => {
            const newReservationPart: Reservation = {
                id: reservationId,
                partId: `${reservationId}-${slot.date}-${slot.time}`,
                patientId: patient.id,
                patientName: patient.name,
                patientChartNumber: patient.chartNumber || '',
                doctor,
                date: slot.date,
                time: slot.time,
                treatments,
                slotActing: slot.acting,
                isContinuation: index > 0,
                memo,
                status: 'confirmed',
            };

            if (!newReservations[slot.date]) newReservations[slot.date] = {};
            if (!newReservations[slot.date][doctor]) newReservations[slot.date][doctor] = {};
            if (!newReservations[slot.date][doctor][slot.time]) newReservations[slot.date][doctor][slot.time] = [];

            newReservations[slot.date][doctor][slot.time].push(newReservationPart);
        });

        return newReservations;
    });

    const reservationDate = slots[0]?.date;
    const reservationTime = slots[0]?.time;

    if (reservationDate && reservationTime) {
      setPaymentsWaiting(prevPayments =>
        prevPayments.map(p =>
          p.patientId === patient.id
          ? { ...p, reservationId, reservationDate, reservationTime }
          : p
        )
      );
    }

    if (slots.length > 1 || slots[0].date !== dateKey || slots[0].time !== time) {
      alert(`ì˜ˆì•½ì´ ì—¬ëŸ¬ ì‹œê°„ëŒ€ì— ê±¸ì³ ${slots[0].date} ${slots[0].time}ë¶€í„° ë°°ì •ë˜ì—ˆìŠµë‹ˆë‹¤. ìì„¸í•œ ë‚´ìš©ì€ ë‹¬ë ¥ì—ì„œ í™•ì¸í•´ì£¼ì„¸ìš”.`);
    }

    alert(`${patient.name}ë‹˜ ì˜ˆì•½ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.`);
  };

  const updateReservation = async (reservationId: string, data: NewReservationData) => {
    const { patient, doctor, date, time, treatments, memo } = data;
    const dateKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
    const totalActing = treatments.reduce((sum, t) => sum + t.acting, 0);

    try {
      // Supabaseì— ì˜ˆì•½ ì—…ë°ì´íŠ¸
      await api.updateReservation(reservationId, {
        patient_id: patient.id,
        doctor,
        reservation_date: dateKey,
        reservation_time: time,
        status: 'confirmed',
        memo: memo || '',
      });

      // ì¹˜ë£Œ í•­ëª© ì¬ì €ì¥ (ê¸°ì¡´ ì‚­ì œ í›„ ìƒˆë¡œ ì¶”ê°€)
      await api.deleteReservationTreatments(reservationId);
      await api.addReservationTreatments(reservationId, treatments);

      console.log('âœ… ì˜ˆì•½ ìˆ˜ì • Supabase ì €ì¥ ì™„ë£Œ');
    } catch (error) {
      console.error('âŒ ì˜ˆì•½ ìˆ˜ì • ì˜¤ë¥˜:', error);
      alert('ì˜ˆì•½ ìˆ˜ì • ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
      return;
    }

    // 1. Create a new state by removing all parts of the old reservation
    const reservationsWithoutOld = JSON.parse(JSON.stringify(reservations));
    for (const date in reservationsWithoutOld) {
        for (const doctor in reservationsWithoutOld[date]) {
            for (const time in reservationsWithoutOld[date][doctor]) {
                reservationsWithoutOld[date][doctor][time] = reservationsWithoutOld[date][doctor][time].filter(
                    (res: Reservation) => res.id !== reservationId
                );
                if (reservationsWithoutOld[date][doctor][time].length === 0) {
                    delete reservationsWithoutOld[date][doctor][time];
                }
            }
            if (Object.keys(reservationsWithoutOld[date][doctor]).length === 0) {
                delete reservationsWithoutOld[date][doctor];
            }
        }
        if (Object.keys(reservationsWithoutOld[date]).length === 0) {
            delete reservationsWithoutOld[date];
        }
    }

    // 2. Add the updated reservation as if it were new, using the old ID
    const slots = findAvailableSlot(dateKey, time, totalActing, reservationsWithoutOld, doctor);

    slots.forEach((slot, index) => {
        const newReservationPart: Reservation = {
            id: reservationId, // Reuse the original ID
            partId: `${reservationId}-${slot.date}-${slot.time}`,
            patientId: patient.id,
            patientName: patient.name,
            patientChartNumber: patient.chartNumber || '',
            doctor,
            date: slot.date,
            time: slot.time,
            treatments,
            slotActing: slot.acting,
            isContinuation: index > 0,
            memo,
            status: 'confirmed',
        };
        if (!reservationsWithoutOld[slot.date]) reservationsWithoutOld[slot.date] = {};
        if (!reservationsWithoutOld[slot.date][doctor]) reservationsWithoutOld[slot.date][doctor] = {};
        if (!reservationsWithoutOld[slot.date][doctor][slot.time]) reservationsWithoutOld[slot.date][doctor][slot.time] = [];
        reservationsWithoutOld[slot.date][doctor][slot.time].push(newReservationPart);
    });

    setReservations(reservationsWithoutOld);

    const reservationDate = slots[0]?.date;
    const reservationTime = slots[0]?.time;

    if (reservationDate && reservationTime) {
      setPaymentsWaiting(prevPayments =>
        prevPayments.map(p =>
          p.patientId === patient.id
          ? { ...p, reservationId, reservationDate, reservationTime }
          : p
        )
      );
    } else { // Reservation might be in a different month, or deleted
       setPaymentsWaiting(prevPayments =>
        prevPayments.map(p => {
          if (p.reservationId === reservationId) {
            const { reservationId, reservationDate, reservationTime, ...rest } = p;
            return rest;
          }
          return p;
        })
      );
    }

    alert('ì˜ˆì•½ì´ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤.');
  };

  const cancelReservation = async (reservationId: string) => {
      try {
        // Supabaseì—ì„œ ì˜ˆì•½ ìƒíƒœë¥¼ 'canceled'ë¡œ ë³€ê²½
        await api.updateReservation(reservationId, { status: 'canceled' });
        console.log('âœ… ì˜ˆì•½ ì·¨ì†Œ Supabase ì €ì¥ ì™„ë£Œ');
      } catch (error) {
        console.error('âŒ ì˜ˆì•½ ì·¨ì†Œ ì˜¤ë¥˜:', error);
        alert('ì˜ˆì•½ ì·¨ì†Œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        return;
      }

      setReservations(prev => {
          const newReservations = JSON.parse(JSON.stringify(prev));
          let patientName = '';
          for (const date in newReservations) {
              for (const doctor in newReservations[date]) {
                  for (const time in newReservations[date][doctor]) {
                      newReservations[date][doctor][time].forEach((res: Reservation) => {
                          if (res.id === reservationId) {
                              res.status = 'canceled';
                              if(!patientName) patientName = res.patientName;
                          }
                      });
                  }
              }
          }

          setPaymentsWaiting(prevPayments =>
            prevPayments.map(p => {
              if (p.reservationId === reservationId) {
                const { reservationId, reservationDate, reservationTime, ...rest } = p;
                return rest;
              }
              return p;
            })
          );

          alert(`${patientName}ë‹˜ì˜ ì˜ˆì•½ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.`);
          return newReservations;
      });
  };

  const deleteReservation = async (reservationId: string) => {
      try {
        // Supabaseì—ì„œ ì˜ˆì•½ ì‚­ì œ
        await api.deleteReservation(reservationId);
        console.log('âœ… ì˜ˆì•½ ì‚­ì œ Supabase ì™„ë£Œ');
      } catch (error) {
        console.error('âŒ ì˜ˆì•½ ì‚­ì œ ì˜¤ë¥˜:', error);
        alert('ì˜ˆì•½ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        return;
      }

      setReservations(prev => {
          const newReservations = JSON.parse(JSON.stringify(prev));
          for (const date in newReservations) {
              for (const doctor in newReservations[date]) {
                  for (const time in newReservations[date][doctor]) {
                      newReservations[date][doctor][time] = newReservations[date][doctor][time].filter(
                          (res: Reservation) => res.id !== reservationId
                      );
                      if (newReservations[date][doctor][time].length === 0) {
                          delete newReservations[date][doctor][time];
                      }
                  }
                  if (Object.keys(newReservations[date][doctor]).length === 0) {
                      delete newReservations[date][doctor];
                  }
              }
              if (Object.keys(newReservations[date]).length === 0) {
                  delete newReservations[date];
              }
          }

          setPaymentsWaiting(prevPayments =>
            prevPayments.map(p => {
              if (p.reservationId === reservationId) {
                const { reservationId, reservationDate, reservationTime, ...rest } = p;
                return rest;
              }
              return p;
            })
          );

          return newReservations;
      });
  };


  const addPatientToConsultation = (patient: Patient) => {
    if (consultationWaitingList.some(p => p.id === patient.id)) {
        alert(`${patient.name}ë‹˜ì€ ì´ë¯¸ ì§„ë£Œ ëŒ€ê¸° ëª©ë¡ì— ìˆìŠµë‹ˆë‹¤.`);
        return;
    }
    const newPatient: Patient = {
        ...patient,
        status: PatientStatus.WAITING_CONSULTATION,
        time: new Date().toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit', hour12: false }),
        details: 'ê²€ìƒ‰ ì¶”ê°€',
    };
    setConsultationWaitingList(prevList => [...prevList, newPatient]);
    alert(`${patient.name}ë‹˜ì„ ì§„ë£Œ ëŒ€ê¸° ëª©ë¡ì— ì¶”ê°€í–ˆìŠµë‹ˆë‹¤.`);
  };

  const addPatientToTreatment = (patient: Patient) => {
    if (treatmentWaitingList.some(p => p.id === patient.id)) {
        alert(`${patient.name}ë‹˜ì€ ì´ë¯¸ ì¹˜ë£Œ ëŒ€ê¸° ëª©ë¡ì— ìˆìŠµë‹ˆë‹¤.`);
        return;
    }
    const newPatient: Patient = {
        ...patient,
        status: PatientStatus.WAITING_TREATMENT,
        time: new Date().toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit', hour12: false }),
        details: 'ê²€ìƒ‰ ì¶”ê°€',
    };
    setTreatmentWaitingList(prevList => [...prevList, newPatient]);
    alert(`${patient.name}ë‹˜ì„ ì¹˜ë£Œ ëŒ€ê¸° ëª©ë¡ì— ì¶”ê°€í–ˆìŠµë‹ˆë‹¤.`);
  };
  
  const handlePatientArrival = (reservation: Reservation, destination: 'consultation' | 'treatment') => {
    const patient = allPatients.find(p => p.id === reservation.patientId);
    if (!patient) {
        alert('í™˜ì ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
        return;
    }

    const currentTime = new Date().toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit', hour12: false });
    const patientToWait = {
        ...patient,
        time: currentTime,
        details: 'ì˜ˆì•½í™˜ì ë‚´ì›',
    };

    if (destination === 'consultation') {
        if (consultationWaitingList.some(p => p.id === patient.id)) {
            alert(`${patient.name}ë‹˜ì€ ì´ë¯¸ ì§„ë£Œ ëŒ€ê¸° ëª©ë¡ì— ìˆìŠµë‹ˆë‹¤.`);
            return;
        }
        patientToWait.status = PatientStatus.WAITING_CONSULTATION;
        setConsultationWaitingList(prev => [...prev, patientToWait]);
    } else { // treatment
        if (treatmentWaitingList.some(p => p.id === patient.id)) {
            alert(`${patient.name}ë‹˜ì€ ì´ë¯¸ ì¹˜ë£Œ ëŒ€ê¸° ëª©ë¡ì— ìˆìŠµë‹ˆë‹¤.`);
            return;
        }
        patientToWait.status = PatientStatus.WAITING_TREATMENT;
        setTreatmentWaitingList(prev => [...prev, patientToWait]);
    }

    // Add actings to queue
    const doctor = reservation.doctor;
    if (DOCTORS.includes(doctor)) {
        const treatmentToActingMap: { [key: string]: { type: ActingType, duration: number } } = {
            'ì¹¨': { type: 'ì¹¨', duration: 15 },
            'ì¶”ë‚˜': { type: 'ì¶”ë‚˜', duration: 20 },
            'ì•½ì´ˆì§„': { type: 'ì•½ìƒë‹´', duration: 30 },
            'ì•½ì¬ì§„': { type: 'ì•½ìƒë‹´', duration: 20 },
        };

        const newActings: Acting[] = reservation.treatments
            .map((treatment, index) => {
                const actingInfo = treatmentToActingMap[treatment.name];
                if (actingInfo) {
                    return {
                        id: `act-${reservation.patientId}-${Date.now()}-${index}`,
                        patientId: reservation.patientId,
                        patientName: reservation.patientName,
                        type: actingInfo.type,
                        duration: actingInfo.duration,
                        source: 'reservation',
                    };
                }
                return null;
            })
            .filter((a): a is Acting => a !== null);

        if (newActings.length > 0) {
            setActingQueues(prev => ({
                ...prev,
                [doctor]: [...(prev[doctor] || []), ...newActings]
            }));
        }
    }

    setReservations(prev => {
        const newReservations = JSON.parse(JSON.stringify(prev));
        for (const date in newReservations) {
            for (const doctor in newReservations[date]) {
                for (const time in newReservations[date][doctor]) {
                    newReservations[date][doctor][time].forEach((res: Reservation) => {
                        if (res.id === reservation.id) {
                            res.status = 'arrived';
                        }
                    });
                }
            }
        }
        return newReservations;
    });

    alert(`${patient.name}ë‹˜ì„ ${destination === 'consultation' ? 'ì§„ë£Œ' : 'ì¹˜ë£Œ'} ëŒ€ê¸° ëª©ë¡ì— ì¶”ê°€í–ˆìŠµë‹ˆë‹¤.`);
  };

  const addNewPatient = async (formData: NewPatientData) => {
    try {
      // ì„ì‹œ í™˜ì ê°ì²´ ìƒì„± (UIìš©)
      const tempPatient: Patient = {
          id: 0, // ì„ì‹œ ID
          name: formData.name,
          chartNumber: formData.chartNumber || '',
          status: PatientStatus.WAITING_CONSULTATION,
          time: new Date().toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit', hour12: false }),
          details: `ì‹ ê·œ | ${formData.treatmentType || 'í¬ë§ì¹˜ë£Œ ë¯¸ì§€ì •'}`,
          dob: formData.dob,
          gender: formData.gender === '' ? undefined : formData.gender,
          phone: formData.phone,
          address: formData.address,
          referralPath: formData.referral,
          registrationDate: new Date().toISOString().split('T')[0],
      };

      // Supabaseì— ì €ì¥
      const savedPatient = await api.createPatient(tempPatient);

      // ì €ì¥ëœ í™˜ì ì •ë³´ë¡œ ì—…ë°ì´íŠ¸
      const newPatient: Patient = {
          ...tempPatient,
          id: savedPatient.id,
          chartNumber: savedPatient.chartNumber || tempPatient.chartNumber,
      };

      setAllPatients(prev => [...prev, newPatient]);
      setConsultationWaitingList(prevList => [newPatient, ...prevList]);

      // Add 'ì´ˆì§„' acting
      const doctor = formData.doctor;
      if (doctor && DOCTORS.includes(doctor)) {
          const newActing: Acting = {
              id: `act-${newPatient.id}-${Date.now()}-0`,
              patientId: newPatient.id,
              patientName: newPatient.name,
              type: 'ì´ˆì§„',
              duration: 30,
              source: 'new_patient',
          };
          setActingQueues(prev => ({
              ...prev,
              [doctor]: [...(prev[doctor] || []), newActing]
          }));
      }

      closeModal();
      alert(`${newPatient.name}ë‹˜ì„ ì‹ ê·œ í™˜ìë¡œ ë“±ë¡í•˜ê³  ì§„ë£Œ ëŒ€ê¸° ëª©ë¡ì— ì¶”ê°€í–ˆìŠµë‹ˆë‹¤.`);
      console.log('âœ… í™˜ì ë“±ë¡ ì™„ë£Œ:', newPatient);
    } catch (error) {
      console.error('âŒ í™˜ì ë“±ë¡ ì˜¤ë¥˜:', error);
      alert('í™˜ì ë“±ë¡ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
    }
  };

  const updatePatientInfo = async (updatedPatientData: Patient) => {
    try {
      // Supabaseì— ì €ì¥
      await api.updatePatient(updatedPatientData.id, updatedPatientData);

      // Update the master list
      setAllPatients(prev => prev.map(p => p.id === updatedPatientData.id ? updatedPatientData : p));

      // Update patient in waiting lists if they are there
      setConsultationWaitingList(prev => prev.map(p => p.id === updatedPatientData.id ? { ...p, ...updatedPatientData } : p));
      setTreatmentWaitingList(prev => prev.map(p => p.id === updatedPatientData.id ? { ...p, ...updatedPatientData } : p));

      // Update name/chart number in reservations
      setReservations(prev => {
          const newReservations = JSON.parse(JSON.stringify(prev));
          for (const date in newReservations) {
              for (const doctor in newReservations[date]) {
                  for (const time in newReservations[date][doctor]) {
                      newReservations[date][doctor][time].forEach((res: Reservation) => {
                          if (res.patientId === updatedPatientData.id) {
                              res.patientName = updatedPatientData.name;
                              res.patientChartNumber = updatedPatientData.chartNumber || '';
                          }
                      });
                  }
              }
          }
          return newReservations;
      });

      alert(`${updatedPatientData.name}ë‹˜ì˜ ì •ë³´ê°€ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤.`);
      console.log('âœ… í™˜ì ì •ë³´ ìˆ˜ì • ì™„ë£Œ:', updatedPatientData);
    } catch (error) {
      console.error('âŒ í™˜ì ì •ë³´ ìˆ˜ì • ì˜¤ë¥˜:', error);
      alert('í™˜ì ì •ë³´ ìˆ˜ì • ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
    }
  };

  const updatePatientDefaultTreatments = async (patientId: number, treatments: DefaultTreatment[]) => {
    try {
      // Supabaseì— ì €ì¥
      await api.savePatientDefaultTreatments(patientId, treatments);

      const updateTreatments = (p: Patient) => {
          if (p.id === patientId) {
              return { ...p, defaultTreatments: treatments };
          }
          return p;
      };
      setAllPatients(prev => prev.map(updateTreatments));
      setTreatmentWaitingList(prev => prev.map(updateTreatments));
      setConsultationWaitingList(prev => prev.map(updateTreatments));

      console.log('âœ… ê¸°ë³¸ ì¹˜ë£Œ ì €ì¥ ì™„ë£Œ');
    } catch (error) {
      console.error('âŒ ê¸°ë³¸ ì¹˜ë£Œ ì €ì¥ ì˜¤ë¥˜:', error);
      alert('ê¸°ë³¸ ì¹˜ë£Œ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
    }
  };


  const deletePatient = async (patientId: number) => {
    const patientToDelete = allPatients.find(p => p.id === patientId);
    if (!patientToDelete) {
        console.error("ì‚­ì œí•  í™˜ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
        return;
    }

    try {
      // Supabaseì—ì„œ soft delete
      await api.deletePatient(patientId);

      // 1. Soft delete by adding deletionDate
      setAllPatients(prev => prev.map(p =>
        p.id === patientId
        ? { ...p, deletionDate: new Date().toISOString() }
        : p
      ));

      // 2. Filter from active UI lists
      setConsultationWaitingList(prev => prev.filter(p => p.id !== patientId));
      setTreatmentWaitingList(prev => prev.filter(p => p.id !== patientId));
      setPaymentsWaiting(prev => prev.filter(p => p.patientId !== patientId));

      // 3. Filter reservations
      setReservations(prev => {
          const newReservations = JSON.parse(JSON.stringify(prev));
          for (const date in newReservations) {
              for (const doctor in newReservations[date]) {
                  for (const time in newReservations[date][doctor]) {
                      newReservations[date][doctor][time] = newReservations[date][doctor][time].filter(
                          (res: Reservation) => res.patientId !== patientId
                      );
                      if (newReservations[date][doctor][time].length === 0) {
                          delete newReservations[date][doctor][time];
                      }
                  }
                  if (Object.keys(newReservations[date][doctor]).length === 0) {
                      delete newReservations[date][doctor];
                  }
              }
              if (Object.keys(newReservations[date]).length === 0) {
                  delete newReservations[date];
              }
          }
          return newReservations;
      });

      alert(`${patientToDelete.name}(${patientToDelete.chartNumber}) ë‹˜ì˜ ì •ë³´ê°€ ì‚­ì œ ì²˜ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤.`);
      console.log('âœ… í™˜ì ì‚­ì œ ì™„ë£Œ');
    } catch (error) {
      console.error('âŒ í™˜ì ì‚­ì œ ì˜¤ë¥˜:', error);
      alert('í™˜ì ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
    }
  };
  
  const restorePatient = async (patientId: number) => {
    const patientToRestore = allPatients.find(p => p.id === patientId);
    if (!patientToRestore) {
        alert("ë³µêµ¬í•  í™˜ì ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
        return;
    }

    try {
      // Supabaseì—ì„œ ë³µêµ¬
      await api.restorePatient(patientId);

      setAllPatients(prev => prev.map(p => {
          if (p.id === patientId) {
              const { deletionDate, ...restoredPatient } = p;
              return restoredPatient;
          }
          return p;
      }));

      alert(`${patientToRestore.name} ë‹˜ì˜ ì •ë³´ê°€ ë³µêµ¬ë˜ì—ˆìŠµë‹ˆë‹¤.`);
      console.log('âœ… í™˜ì ë³µêµ¬ ì™„ë£Œ');
    } catch (error) {
      console.error('âŒ í™˜ì ë³µêµ¬ ì˜¤ë¥˜:', error);
      alert('í™˜ì ë³µêµ¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
    }
  };

  const handleRequestDeletePatient = (patientId: number) => {
    setPatientIdToDelete(patientId);
  };

  const handleConfirmDelete = () => {
      if (patientIdToDelete) {
          deletePatient(patientIdToDelete);
      }
      setPatientIdToDelete(null);
  };

  const handleCancelDelete = () => {
      setPatientIdToDelete(null);
  };

  const addBulkPatients = async (newPatientsData: BulkPatientData[]) => {
    const updatedPatients: Patient[] = [];
    const newPatients: Patient[] = [];
    const failures: BulkAddFailure[] = [];

    const existingPatientMapByChartNumber = new Map(allPatients.map(p => [p.chartNumber, p]));
    const chartNumbersInFile = new Set<string>();

    try {
      // 1ë‹¨ê³„: ê²€ì¦ ë° ë¶„ë¥˜
      for (const data of newPatientsData) {
          const name = String(data.name || '').trim();
          const chartNumber = data.chartNumber ? String(data.chartNumber).trim() : '';

          if (!name) {
              failures.push({ name: '(ì´ë¦„ ì—†ìŒ)', chartNumber, reason: 'í™˜ì ì´ë¦„ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.' });
              continue;
          }

          if (chartNumber) {
              if(chartNumbersInFile.has(chartNumber)) {
                  failures.push({ name, chartNumber, reason: 'ì—‘ì…€ íŒŒì¼ ë‚´ ì¤‘ë³µëœ ì°¨íŠ¸ë²ˆí˜¸ì…ë‹ˆë‹¤.' });
                  continue;
              }
              chartNumbersInFile.add(chartNumber);
          }

          const existingPatient = chartNumber ? existingPatientMapByChartNumber.get(chartNumber) : undefined;

          if (existingPatient) { // Update case
              const updatedPatient = { ...existingPatient };
              if(data.name) updatedPatient.name = data.name;
              if(data.dob) updatedPatient.dob = data.dob;
              if(data.gender !== undefined) updatedPatient.gender = data.gender;
              if(data.address !== undefined) updatedPatient.address = data.address;
              if(data.phone !== undefined) updatedPatient.phone = data.phone;
              if(data.details !== undefined) updatedPatient.referralPath = data.details;
              if(data.registrationDate) updatedPatient.registrationDate = data.registrationDate;
              updatedPatients.push(updatedPatient);
          } else { // New patient case
              const tempPatient: Patient = {
                  id: 0, // ì„ì‹œ ID, APIì—ì„œ í• ë‹¹ë¨
                  name,
                  chartNumber: chartNumber || '', // APIì—ì„œ ìƒì„±
                  status: PatientStatus.COMPLETED,
                  time: '',
                  details: 'ì¼ê´„ë“±ë¡',
                  dob: data.dob,
                  gender: data.gender,
                  address: data.address,
                  phone: data.phone,
                  referralPath: data.details || '',
                  registrationDate: data.registrationDate || new Date().toISOString().split('T')[0],
              };
              newPatients.push(tempPatient);
          }
      }

      // 2ë‹¨ê³„: Supabaseì— ì €ì¥
      const savedNewPatients: Patient[] = [];

      // ìƒˆ í™˜ì ì €ì¥
      for (const patient of newPatients) {
          try {
              const saved = await api.createPatient(patient);
              savedNewPatients.push(saved);
          } catch (error) {
              console.error(`í™˜ì ì €ì¥ ì‹¤íŒ¨: ${patient.name}`, error);
              failures.push({ name: patient.name, chartNumber: patient.chartNumber, reason: 'ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥ ì˜¤ë¥˜' });
          }
      }

      // ê¸°ì¡´ í™˜ì ì—…ë°ì´íŠ¸
      for (const patient of updatedPatients) {
          try {
              await api.updatePatient(patient.id, patient);
          } catch (error) {
              console.error(`í™˜ì ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: ${patient.name}`, error);
              failures.push({ name: patient.name, chartNumber: patient.chartNumber || '', reason: 'ë°ì´í„°ë² ì´ìŠ¤ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜' });
          }
      }

      // 3ë‹¨ê³„: ë¡œì»¬ state ì—…ë°ì´íŠ¸
      if (savedNewPatients.length > 0 || updatedPatients.length > 0) {
          setAllPatients(prevPatients => {
              const updatedPatientMap = new Map(updatedPatients.map(p => [p.id, p]));
              const processedPatients = prevPatients.map(p => updatedPatientMap.get(p.id) || p);
              return [...processedPatients, ...savedNewPatients];
          });
      }

      setBulkAddResult({ new: savedNewPatients.length, updated: updatedPatients.length, failures });
      console.log(`âœ… ì¼ê´„ ë“±ë¡ ì™„ë£Œ: ì‹ ê·œ ${savedNewPatients.length}ëª…, ì—…ë°ì´íŠ¸ ${updatedPatients.length}ëª…, ì‹¤íŒ¨ ${failures.length}ëª…`);

    } catch (error) {
      console.error('âŒ ì¼ê´„ ë“±ë¡ ì˜¤ë¥˜:', error);
      alert('ì¼ê´„ ë“±ë¡ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
    }
  };


  const movePatient = (patientToMove: Patient) => {
    const currentTime = new Date().toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit', hour12: false });

    if (patientToMove.status === PatientStatus.WAITING_CONSULTATION) {
        setConsultationWaitingList(prev => prev.filter(p => p.id !== patientToMove.id));
        const updatedPatient = {
            ...patientToMove,
            status: PatientStatus.WAITING_TREATMENT,
            time: currentTime,
            details: 'ì§„ë£Œì™„ë£Œ',
        };
        setTreatmentWaitingList(prev => [...prev, updatedPatient]);
    } else if (patientToMove.status === PatientStatus.WAITING_TREATMENT) {
        setTreatmentWaitingList(prev => prev.filter(p => p.id !== patientToMove.id));
        const updatedPatient = {
            ...patientToMove,
            status: PatientStatus.WAITING_CONSULTATION,
            time: currentTime,
            details: 'ì¬ì§„ë£Œìš”ì²­',
        };
        setConsultationWaitingList(prev => [...prev, updatedPatient]);
    }
  };

  const handlePatientDrop = (
    draggedPatientId: number,
    sourceListType: 'consultation' | 'treatment',
    destinationListType: 'consultation' | 'treatment',
    targetPatientId: number | null
  ) => {
    const sourceList = sourceListType === 'consultation' ? consultationWaitingList : treatmentWaitingList;
    const setSourceList = sourceListType === 'consultation' ? setConsultationWaitingList : setTreatmentWaitingList;
    const draggedPatient = sourceList.find(p => p.id === draggedPatientId);

    if (!draggedPatient) return;

    // Only allow reordering within the same list.
    if (sourceListType === destinationListType) {
        const list = [...sourceList];
        const draggedIndex = list.findIndex(p => p.id === draggedPatientId);
        list.splice(draggedIndex, 1);
        const targetIndex = targetPatientId !== null ? list.findIndex(p => p.id === targetPatientId) : list.length;
        list.splice(targetIndex, 0, draggedPatient);
        setSourceList(list);
    }
  };

  const handleOpenPaymentModal = (payment: Payment) => {
    setSelectedPayment(payment);
    openModal('payment', `${payment.patientName}ë‹˜ ìˆ˜ë‚© ì²˜ë¦¬`);
  };

  const handleOpenReservationForPatient = (payment: Payment) => {
    if (payment.reservationId) {
        const allReservations: Reservation[] = Object.values(reservations)
            .flatMap(docSlots => Object.values(docSlots))
            .flatMap(timeSlots => Object.values(timeSlots))
            .flat();
        
        const reservationToEdit = allReservations.find(r => r.id === payment.reservationId);
        if (reservationToEdit) {
            handleEditReservation(reservationToEdit);
        } else {
            alert('í•´ë‹¹ ì˜ˆì•½ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì‚­ì œë˜ì—ˆê±°ë‚˜ ë³€ê²½ë˜ì—ˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
        }
    } else {
        const patient = allPatients.find(p => p.id === payment.patientId);
        if (patient) {
            setPatientForNewReservation(patient);
            openModal('reservation', `${patient.name}ë‹˜ ì˜ˆì•½`, true);
        } else {
            alert('í™˜ì ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
        }
    }
  };

  const handleCompletePayment = async (
    originalPayment: Payment,
    details: {
      totalAmount: number;
      items: PaymentItem[];
      remainingAmount: number;
      treatmentItems: TreatmentDetailItem[];
    }
  ) => {
    try {
      // Supabaseì— ê²°ì œ ì™„ë£Œ ì €ì¥
      await api.completePayment(originalPayment.id, {
        totalAmount: details.totalAmount,
        paidAmount: details.totalAmount - details.remainingAmount,
        remainingAmount: details.remainingAmount,
        paymentMethods: details.items.map(item => ({
          method: item.method,
          amount: parseInt(item.amount, 10) || 0,
        })),
        treatmentItems: details.treatmentItems,
      });

      setPaymentsWaiting(prev => prev.filter(p => p.id !== originalPayment.id));

      const newCompletedPayment: CompletedPayment = {
          id: Date.now(),
          paymentId: originalPayment.id,
          patientId: originalPayment.patientId,
          patientName: originalPayment.patientName,
          patientChartNumber: originalPayment.patientChartNumber,
          treatmentItems: details.treatmentItems,
          totalAmount: details.totalAmount,
          paidAmount: details.totalAmount - details.remainingAmount,
          remainingAmount: details.remainingAmount,
          paymentMethods: details.items.map(item => ({
              method: item.method,
              amount: parseInt(item.amount, 10) || 0,
          })),
          timestamp: new Date().toISOString(),
      };

      setCompletedPayments(prev => [newCompletedPayment, ...prev]);

      closeModal();
      const alertMessage = details.remainingAmount > 0
        ? `ìˆ˜ë‚© ì²˜ë¦¬ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ë¯¸ìˆ˜ê¸ˆ: ${details.remainingAmount.toLocaleString()}ì›`
        : 'ìˆ˜ë‚© ì²˜ë¦¬ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.';
      alert(alertMessage);
      console.log('âœ… ê²°ì œ ì™„ë£Œ ì €ì¥ ì™„ë£Œ');
    } catch (error) {
      console.error('âŒ ê²°ì œ ì™„ë£Œ ì²˜ë¦¬ ì˜¤ë¥˜:', error);
      alert('ê²°ì œ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
    }
  };
  
  const handleFinishConsultation = async (patientId: number, destination: 'treatment' | 'payment') => {
    const patient = allPatients.find(p => p.id === patientId);
    if (!patient) {
        alert("í™˜ì ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
        return;
    }

    // 1. Update consultation room to be available
    setConsultationRooms(prevRooms =>
        prevRooms.map(room =>
            room.patientId === patientId
            ? { ...room, status: 'available', patientId: undefined, patientName: undefined, patientDetails: undefined }
            : room
        )
    );

    // 2. Remove patient from the consultation waiting list
    setConsultationWaitingList(prev => prev.filter(p => p.id !== patientId));

    const currentTime = new Date().toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit', hour12: false });

    if (destination === 'treatment') {
        const patientForTreatment: Patient = {
            ...patient,
            status: PatientStatus.WAITING_TREATMENT,
            time: currentTime,
            details: 'ì§„ë£Œì™„ë£Œ',
        };
        setTreatmentWaitingList(prev => [...prev, patientForTreatment]);
        alert(`${patient.name}ë‹˜ì„ ì¹˜ë£Œ ëŒ€ê¸° ëª©ë¡ìœ¼ë¡œ ì´ë™í–ˆìŠµë‹ˆë‹¤.`);
    } else { // destination === 'payment'
        try {
          const newPayment: Payment = {
              id: 0, // ì„ì‹œ ID, APIì—ì„œ ìƒì„±ë¨
              patientId: patient.id,
              patientName: patient.name,
              patientChartNumber: patient.chartNumber,
              details: 'ì§„ë£Œë¹„',
              isPaid: false,
          };

          // Supabaseì— ê²°ì œ ìƒì„±
          const paymentId = await api.createPayment(newPayment);

          setPaymentsWaiting(prev => [...prev, { ...newPayment, id: paymentId }]);
          alert(`${patient.name}ë‹˜ì„ ìˆ˜ë‚© ëŒ€ê¸° ëª©ë¡ìœ¼ë¡œ ì´ë™í–ˆìŠµë‹ˆë‹¤.`);
          console.log('âœ… ê²°ì œ ìƒì„± ì™„ë£Œ');
        } catch (error) {
          console.error('âŒ ê²°ì œ ìƒì„± ì˜¤ë¥˜:', error);
          alert('ìˆ˜ë‚© ëŒ€ê¸° ì¶”ê°€ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        }
    }
  };

  const handleAssignPatientToConsultationRoom = (patientId: number, roomId: number, sourceListType: 'consultation' | 'treatment') => {
    const sourceList = sourceListType === 'consultation' ? consultationWaitingList : treatmentWaitingList;
    const setSourceList = sourceListType === 'consultation' ? setConsultationWaitingList : setTreatmentWaitingList;

    const patientToAssign = sourceList.find(p => p.id === patientId);
    const targetRoom = consultationRooms.find(r => r.id === roomId);

    if (!patientToAssign) {
      alert('ëŒ€ê¸° ëª©ë¡ì—ì„œ í™˜ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
      return;
    }
    if (!targetRoom) {
      alert('ì§„ë£Œì‹¤ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
      return;
    }
    if (targetRoom.status !== 'available') {
      alert(`${targetRoom.roomName}ì€ í˜„ì¬ ì‚¬ìš© ì¤‘ì…ë‹ˆë‹¤.`);
      return;
    }

    // 1. Remove patient from the correct waiting list
    setSourceList(prev => prev.filter(p => p.id !== patientId));

    // 2. Update the consultation room
    setConsultationRooms(prev => prev.map(room => {
      if (room.id === roomId) {
        return {
          ...room,
          status: 'in_consultation',
          patientId: patientToAssign.id,
          patientName: patientToAssign.name,
          patientDetails: sourceListType === 'treatment' ? 'ì¹˜ë£Œì‹¤->ì¬ì§„ë£Œ' : patientToAssign.details,
        };
      }
      return room;
    }));

    alert(`${patientToAssign.name}ë‹˜ì„ ${targetRoom.roomName}ì— ë°°ì •í–ˆìŠµë‹ˆë‹¤.`);
  };

  const handleMovePatientToPayment = async (patientId: number, sourceList: 'consultation' | 'treatment' | 'treatment_room') => {
    let patientToMove: Patient | undefined;

    if (sourceList === 'consultation') {
        patientToMove = consultationWaitingList.find(p => p.id === patientId);
        if (patientToMove) setConsultationWaitingList(prev => prev.filter(p => p.id !== patientId));
    } else if (sourceList === 'treatment') {
        patientToMove = treatmentWaitingList.find(p => p.id === patientId);
        if (patientToMove) setTreatmentWaitingList(prev => prev.filter(p => p.id !== patientId));
    } else { // from treatment room
        patientToMove = allPatients.find(p => p.id === patientId);
    }

    if (!patientToMove) {
        alert("í™˜ì ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
        return;
    }

    try {
      const newPayment: Payment = {
        id: 0, // ì„ì‹œ ID, APIì—ì„œ ìƒì„±ë¨
        patientId: patientToMove.id,
        patientName: patientToMove.name,
        patientChartNumber: patientToMove.chartNumber,
        details: 'ì¹˜ë£Œë¹„',
        isPaid: false,
      };

      const paymentId = await api.createPayment(newPayment);
      setPaymentsWaiting(prev => [...prev, { ...newPayment, id: paymentId }]);
      alert(`${patientToMove.name}ë‹˜ì„ ìˆ˜ë‚© ëŒ€ê¸° ëª©ë¡ìœ¼ë¡œ ì´ë™í–ˆìŠµë‹ˆë‹¤.`);
      console.log('âœ… ê²°ì œ ìƒì„± ì™„ë£Œ');
    } catch (error) {
      console.error('âŒ ê²°ì œ ìƒì„± ì˜¤ë¥˜:', error);
      alert('ìˆ˜ë‚© ëŒ€ê¸° ì¶”ê°€ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
    }
  };


  const handleMovePatientFromPaymentToWaiting = (paymentId: number, destination: 'consultation' | 'treatment') => {
    const paymentToMove = paymentsWaiting.find(p => p.id === paymentId);
    if (!paymentToMove) {
        alert("ìˆ˜ë‚© ëŒ€ê¸° ëª©ë¡ì—ì„œ í•´ë‹¹ í•­ëª©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
        return;
    }

    const patientInfo = allPatients.find(p => p.id === paymentToMove.patientId);
    if (!patientInfo) {
        alert("í™˜ì ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
        return;
    }

    setPaymentsWaiting(prev => prev.filter(p => p.id !== paymentId));

    const currentTime = new Date().toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit', hour12: false });
    
    if (destination === 'consultation') {
        const patientForConsultation: Patient = {
            ...patientInfo,
            status: PatientStatus.WAITING_CONSULTATION,
            time: currentTime,
            details: 'ìˆ˜ë‚©->ì§„ë£Œ',
        };
        setConsultationWaitingList(prev => [...prev, patientForConsultation]);
        alert(`${patientInfo.name}ë‹˜ì„ ì§„ë£Œ ëŒ€ê¸° ëª©ë¡ìœ¼ë¡œ ì´ë™í–ˆìŠµë‹ˆë‹¤.`);
    } else { // destination === 'treatment'
        const patientForTreatment: Patient = {
            ...patientInfo,
            status: PatientStatus.WAITING_TREATMENT,
            time: currentTime,
            details: 'ìˆ˜ë‚©->ì¹˜ë£Œ',
        };
        setTreatmentWaitingList(prev => [...prev, patientForTreatment]);
        alert(`${patientInfo.name}ë‹˜ì„ ì¹˜ë£Œ ëŒ€ê¸° ëª©ë¡ìœ¼ë¡œ ì´ë™í–ˆìŠµë‹ˆë‹¤.`);
    }
  };

  const updateMedicalStaff = async (updatedStaff: MedicalStaff) => {
      try {
          await api.updateMedicalStaff(updatedStaff.id, updatedStaff);
          setMedicalStaff(prev => prev.map(staff => staff.id === updatedStaff.id ? updatedStaff : staff));
          alert(`${updatedStaff.name}ë‹˜ì˜ ì •ë³´ê°€ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤.`);
      } catch (error) {
          console.error('ì˜ë£Œì§„ ìˆ˜ì • ì˜¤ë¥˜:', error);
          alert('ì˜ë£Œì§„ ì •ë³´ ìˆ˜ì • ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
      }
  };

  const addMedicalStaff = async (newStaffData: Omit<MedicalStaff, 'id'>) => {
      try {
          const newStaff = await api.createMedicalStaff(newStaffData);
          setMedicalStaff(prev => [...prev, newStaff]);
          alert(`${newStaff.name}ë‹˜ì„ ì‹ ê·œ ì˜ë£Œì§„ìœ¼ë¡œ ë“±ë¡í–ˆìŠµë‹ˆë‹¤.`);
      } catch (error) {
          console.error('ì˜ë£Œì§„ ì¶”ê°€ ì˜¤ë¥˜:', error);
          alert('ì˜ë£Œì§„ ì¶”ê°€ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
      }
  };

  const deleteMedicalStaff = async (staffId: number) => {
      const staffToDelete = medicalStaff.find(s => s.id === staffId);
      if (!staffToDelete) return;

      try {
          await api.deleteMedicalStaff(staffId);
          setMedicalStaff(prev => prev.filter(staff => staff.id !== staffId));
          alert(`${staffToDelete.name}ë‹˜ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.`);
      } catch (error) {
          console.error('ì˜ë£Œì§„ ì‚­ì œ ì˜¤ë¥˜:', error);
          alert('ì˜ë£Œì§„ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
      }
  };

  const updateStaff = async (updatedStaffMember: Staff) => {
      try {
          await api.updateStaff(updatedStaffMember.id, updatedStaffMember);
          setStaff(prev => prev.map(s => s.id === updatedStaffMember.id ? updatedStaffMember : s));
          alert(`${updatedStaffMember.name}ë‹˜ì˜ ì •ë³´ê°€ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤.`);
      } catch (error) {
          console.error('ìŠ¤íƒœí”„ ìˆ˜ì • ì˜¤ë¥˜:', error);
          alert('ìŠ¤íƒœí”„ ì •ë³´ ìˆ˜ì • ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
      }
  };

  const addStaff = async (newStaffData: Omit<Staff, 'id'>) => {
      try {
          const newStaffMember = await api.createStaff(newStaffData);
          setStaff(prev => [...prev, newStaffMember]);
          alert(`${newStaffMember.name}ë‹˜ì„ ì‹ ê·œ ìŠ¤íƒœí”„ë¡œ ë“±ë¡í–ˆìŠµë‹ˆë‹¤.`);
      } catch (error) {
          console.error('ìŠ¤íƒœí”„ ì¶”ê°€ ì˜¤ë¥˜:', error);
          alert('ìŠ¤íƒœí”„ ì¶”ê°€ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
      }
  };

  const deleteStaff = async (staffId: number) => {
      const staffToDelete = staff.find(s => s.id === staffId);
      if (!staffToDelete) return;

      try {
          await api.deleteStaff(staffId);
          setStaff(prev => prev.filter(s => s.id !== staffId));
          alert(`${staffToDelete.name}ë‹˜ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.`);
      } catch (error) {
          console.error('ìŠ¤íƒœí”„ ì‚­ì œ ì˜¤ë¥˜:', error);
          alert('ìŠ¤íƒœí”„ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
      }
  };

  const updateUncoveredCategories = async (categories: UncoveredCategories) => {
      try {
          await api.saveUncoveredCategories(categories);
          setUncoveredCategories(categories);
          alert('ë¹„ê¸‰ì—¬ ì¹´í…Œê³ ë¦¬ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
      } catch (error) {
          console.error('ë¹„ê¸‰ì—¬ ì¹´í…Œê³ ë¦¬ ì €ì¥ ì˜¤ë¥˜:', error);
          alert('ë¹„ê¸‰ì—¬ ì¹´í…Œê³ ë¦¬ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
      }
  };

  const handleUpdateTreatmentRooms = async (updatedRooms: TreatmentRoom[]) => {
      // ë¡œì»¬ ìƒíƒœ ì—…ë°ì´íŠ¸
      setTreatmentRooms(updatedRooms);

      // ë³€ê²½ëœ ë°© ì°¾ì•„ì„œ DBì— ì €ì¥
      try {
          // ì´ì „ ìƒíƒœì™€ ë¹„êµí•˜ì—¬ ë³€ê²½ëœ ë°©ë§Œ ì°¾ê¸°
          const currentRooms = treatmentRooms;

          for (const updatedRoom of updatedRooms) {
              const oldRoom = currentRooms.find(r => r.id === updatedRoom.id);

              // ë°© ìƒíƒœê°€ ë³€ê²½ë˜ì—ˆëŠ”ì§€ í™•ì¸ (ê°„ë‹¨í•œ JSON ë¹„êµ)
              if (oldRoom && JSON.stringify(oldRoom) !== JSON.stringify(updatedRoom)) {
                  console.log(`ğŸ”„ ì¹˜ë£Œì‹¤ ${updatedRoom.name} ìƒíƒœ ë³€ê²½ - DB ì €ì¥ ì¤‘...`);
                  await api.updateTreatmentRoom(updatedRoom.id, updatedRoom);
              }
          }
      } catch (error) {
          console.error('âŒ ì¹˜ë£Œì‹¤ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜:', error);
          // ì˜¤ë¥˜ê°€ ë‚˜ë„ ë¡œì»¬ ìƒíƒœëŠ” ìœ ì§€ (ì‚¬ìš©ì ê²½í—˜ì„ ìœ„í•´)
      }
  };

  const handleCompleteActing = (doctorId: string, actingId: string) => {
    const actingQueue = actingQueues[doctorId];
    const acting = actingQueue.find(a => a.id === actingId);

    if (!acting) return;

    if (!window.confirm(`${acting.patientName}ë‹˜ì˜ '${acting.type}' ì•¡íŒ…ì„ ì™„ë£Œí•˜ê³  ëŒ€ê¸°ì—´ì—ì„œ ì œê±°í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
        return;
    }

    if (acting.type === 'ì¹¨') {
        const patientRoom = treatmentRooms.find(r => r.patientId === acting.patientId);
        if (!patientRoom) {
            alert("í•´ë‹¹ í™˜ìê°€ ë°°ì •ëœ ì¹˜ë£Œì‹¤ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì¹˜ë£Œì‹¤ì— ë¨¼ì € ë°°ì •í•´ì£¼ì„¸ìš”.");
            return;
        }

        const treatmentToStart = patientRoom.sessionTreatments.find(t => t.name === 'ì¹¨' && t.status !== 'running' && t.status !== 'completed');
        if (!treatmentToStart) {
            alert("í•´ë‹¹ í™˜ìì˜ 'ì¹¨' ì¹˜ë£Œ í•­ëª©ì„ ì°¾ì„ ìˆ˜ ì—†ê±°ë‚˜ ì´ë¯¸ ì§„í–‰ì¤‘/ì™„ë£Œ ìƒíƒœì…ë‹ˆë‹¤.");
            return;
        }

        // Pre-checks passed, now update both states
        setTreatmentRooms(prevRooms => prevRooms.map(room => {
            if (room.id === patientRoom.id) {
                const newTreatments = room.sessionTreatments.map(tx => {
                    if (tx.id === treatmentToStart.id) {
                        return { ...tx, status: 'running' as const, startTime: new Date().toISOString(), elapsedSeconds: 0 };
                    }
                    return tx;
                });
                return { ...room, sessionTreatments: newTreatments };
            }
            return room;
        }));
        
        setActingQueues(prevQueues => ({
            ...prevQueues,
            [doctorId]: prevQueues[doctorId].filter(a => a.id !== actingId)
        }));

    } else {
        // For other actings, just remove from the queue
        setActingQueues(prevQueues => ({
            ...prevQueues,
            [doctorId]: prevQueues[doctorId].filter(a => a.id !== actingId)
        }));
    }
  };

  const addActing = (doctorId: string, type: 'ëŒ€ê¸°' | 'ì´ˆì§„' | 'ìƒë‹´') => {
    let patientName: string;
    let duration: number;
    let actingType: ActingType;

    switch (type) {
        case 'ì´ˆì§„':
            patientName = '';
            duration = 30;
            actingType = 'ì´ˆì§„';
            break;
        case 'ìƒë‹´':
            patientName = '';
            duration = 25;
            actingType = 'ì•½ìƒë‹´';
            break;
        case 'ëŒ€ê¸°':
            patientName = '';
            duration = 0;
            actingType = 'ëŒ€ê¸°';
            break;
        default:
            return;
    }

    const newActing: Acting = {
        id: `act-manual-${Date.now()}`,
        patientId: -1, // Placeholder patient ID
        patientName: patientName,
        type: actingType,
        duration: duration,
        source: 'manual',
    };
    
    setActingQueues(prevQueues => {
        const newQueues = { ...prevQueues };
        const currentQueue = newQueues[doctorId] || [];
        newQueues[doctorId] = [newActing, ...currentQueue];
        return newQueues;
    });
  };

  const deleteActing = (doctorId: string, actingId: string) => {
    setActingQueues(prev => ({
        ...prev,
        [doctorId]: prev[doctorId].filter(a => a.id !== actingId)
    }));
  };

  const handleEditActing = (doctorId: string, acting: Acting) => {
    setActingToEdit({ doctorId, acting });
    openModal('editActing', 'ì•¡íŒ… í¸ì§‘');
  };

  const updateActing = (doctorId: string, actingId: string, updatedData: { patientName: string; duration: number; memo: string; }) => {
    setActingQueues(prev => ({
        ...prev,
        [doctorId]: prev[doctorId].map(a => 
            a.id === actingId ? { ...a, ...updatedData } : a
        )
    }));
    closeModal();
  };

  const EditActingForm = () => {
    if (!actingToEdit) return null;
    const { acting, doctorId } = actingToEdit;
    
    const [formData, setFormData] = useState({
        patientName: acting.patientName,
        type: acting.type,
        duration: acting.duration,
        memo: acting.memo || '',
    });

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
        const { name, value } = e.target;
        const targetType = (e.target as HTMLInputElement).type;
        setFormData(prev => ({
            ...prev,
            [name]: targetType === 'number' ? parseInt(value, 10) || 0 : value,
        }));
    };

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        const { type, ...dataToUpdate } = formData;
        updateActing(doctorId, acting.id, dataToUpdate);
    };

    return (
        <form onSubmit={handleSubmit} className="space-y-4">
            <div>
                <label className="block text-sm font-medium text-gray-700">ì•¡íŒ… ì¢…ë¥˜</label>
                <div className="mt-1 block w-full px-3 py-2 border border-gray-200 rounded-md bg-gray-100 text-gray-600 sm:text-sm">
                    {formData.type}
                </div>
            </div>
            <div>
                <label htmlFor="patientName" className="block text-sm font-medium text-gray-700">í™˜ì ì´ë¦„</label>
                <input
                    type="text"
                    id="patientName"
                    name="patientName"
                    value={formData.patientName}
                    onChange={handleChange}
                    className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-clinic-secondary focus:border-clinic-secondary sm:text-sm"
                />
            </div>
            <div>
                <label htmlFor="duration" className="block text-sm font-medium text-gray-700">ì˜ˆìƒ ì‹œê°„ (ë¶„)</label>
                <input
                    type="number"
                    id="duration"
                    name="duration"
                    value={formData.duration}
                    onChange={handleChange}
                    className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-clinic-secondary focus:border-clinic-secondary sm:text-sm"
                />
            </div>
            <div>
                <label htmlFor="memo" className="block text-sm font-medium text-gray-700">ë©”ëª¨</label>
                <textarea
                    id="memo"
                    name="memo"
                    rows={3}
                    value={formData.memo}
                    onChange={handleChange}
                    className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-clinic-secondary focus:border-clinic-secondary sm:text-sm"
                    placeholder="ì•¡íŒ… ê´€ë ¨ ë©”ëª¨ë¥¼ ì…ë ¥í•˜ì„¸ìš”..."
                ></textarea>
            </div>
            <div className="flex justify-end pt-4 border-t mt-4 space-x-2">
                <button type="button" onClick={closeModal} className="px-6 py-2 bg-gray-200 text-gray-800 font-semibold rounded-md hover:bg-gray-300 transition-colors">ì·¨ì†Œ</button>
                <button type="submit" className="px-6 py-2 bg-clinic-primary text-white font-semibold rounded-md hover:bg-clinic-secondary focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-clinic-secondary transition-colors">ì €ì¥</button>
            </div>
        </form>
    );
  };


  const renderModalContent = () => {
    switch (modalType) {
      case 'reservation':
        return <ReservationModal 
          reservations={reservations}
          addNewReservation={addNewReservation}
          updateReservation={updateReservation}
          cancelReservation={cancelReservation}
          deleteReservation={deleteReservation}
          closeModal={closeModal}
          allPatients={activePatients}
          setModalWide={setIsModalWide}
          setModalTitle={setModalTitle}
          initialReservationForEdit={editingReservation}
          initialPatientForNew={patientForNewReservation}
        />;
      case 'newPatient':
        return <NewPatientForm addNewPatient={addNewPatient} onClose={closeModal} />;
      case 'patientSearch':
        return <PatientSearch 
          addPatientToConsultation={addPatientToConsultation} 
          addPatientToTreatment={addPatientToTreatment}
          allPatients={activePatients}
          updatePatientInfo={updatePatientInfo}
          deletePatient={handleRequestDeletePatient}
        />;
      case 'payment':
        return <PaymentModal 
          payment={selectedPayment}
          onClose={closeModal}
          onComplete={handleCompletePayment}
          uncoveredCategories={uncoveredCategories}
        />;
      case 'dailyPayments':
        return <DailyPaymentSummary completedPayments={completedPayments} />;
      case 'stats':
        return <p>í†µê³„ ì •ë³´ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</p>;
      case 'settings':
        return <Settings
          addBulkPatients={addBulkPatients}
          allPatients={activePatients}
          deletePatient={handleRequestDeletePatient}
          deletedPatients={deletedPatients}
          restorePatient={restorePatient}
          medicalStaff={medicalStaff}
          updateMedicalStaff={updateMedicalStaff}
          addMedicalStaff={addMedicalStaff}
          deleteMedicalStaff={deleteMedicalStaff}
          staff={staff}
          updateStaff={updateStaff}
          addStaff={addStaff}
          deleteStaff={deleteStaff}
          uncoveredCategories={uncoveredCategories}
          updateUncoveredCategories={updateUncoveredCategories}
        />;
      case 'editActing':
        return <EditActingForm />;
      default:
        return null;
    }
  };
  
  const handleLogin = (id: string, pass: string) => {
    const user = USERS.find(u => u.id === id && u.password === pass);
    if (user) {
      setCurrentUser(user);
    } else {
      alert('ë“±ë¡ëœ ì‚¬ìš©ìê°€ ì•„ë‹™ë‹ˆë‹¤.');
    }
  };

  const handleLogout = () => {
    setCurrentUser(null);
  };

  if (!currentUser) {
    return <LoginScreen onLogin={handleLogin} />;
  }


  return (
    <div className="flex flex-col h-screen text-clinic-text-primary overflow-hidden">
      {currentView === 'dashboard' && (
        <>
          <Header 
            onOpenModal={openModal}
            onNavigate={setCurrentView}
            currentUser={currentUser}
            onLogout={handleLogout}
          />
          <main className="flex-grow p-4 lg:p-6 grid grid-cols-1 md:grid-cols-2 xl:grid-cols-5 gap-4 lg:gap-6 min-h-0">
            {/* 1. ì˜ˆì•½í˜„í™© */}
            <div className="xl:col-span-1 flex flex-col min-h-0">
              <ReservationStatus 
                reservations={reservations} 
                onEditReservation={handleEditReservation} 
                onPatientArrival={handlePatientArrival} 
              />
            </div>
            
            {/* 2. ì§„ë£Œì‹¤í˜„í™©, ì§„ë£ŒëŒ€ê¸° */}
            <div className="xl:col-span-1 flex flex-col gap-4 lg:gap-6">
              <ConsultationStatus 
                rooms={consultationRooms}
                onFinishConsultation={handleFinishConsultation}
                onAssignPatient={handleAssignPatientToConsultationRoom}
              />
              <WaitingList
                title="ì§„ë£Œ ëŒ€ê¸°"
                icon="fa-solid fa-user-doctor"
                list={consultationWaitingList}
                listType="consultation"
                onPatientClick={movePatient}
                onPatientDrop={handlePatientDrop}
                onMoveToPayment={(id) => handleMovePatientToPayment(id, 'consultation')}
              />
            </div>
            
            {/* 3. ì¹˜ë£ŒëŒ€ê¸° */}
            <div className="xl:col-span-1 flex flex-col min-h-0">
              <WaitingList
                title="ì¹˜ë£Œ ëŒ€ê¸°" 
                icon="fa-solid fa-bed-pulse"
                list={treatmentWaitingList}
                listType="treatment"
                onPatientClick={movePatient}
                onPatientDrop={handlePatientDrop}
                onMoveToPayment={(id) => handleMovePatientToPayment(id, 'treatment')}
              />
            </div>

            {/* 4. ì¹˜ë£Œì‹¤ í˜„í™© */}
            <div className="xl:col-span-1 flex flex-col min-h-0">
              <TreatmentRoomStatus treatmentRooms={treatmentRooms} />
            </div>
            
            {/* 5. ìˆ˜ë‚©ë°ì˜ˆì•½ */}
            <div className="xl:col-span-1 flex flex-col min-h-0">
              <PaymentStatus 
                  payments={paymentsWaiting} 
                  onPaymentClick={handleOpenPaymentModal}
                  onReservationClick={handleOpenReservationForPatient} 
                  onMoveToWaiting={handleMovePatientFromPaymentToWaiting}
              />
            </div>
          </main>
        </>
      )}

      {currentView === 'treatment' && (
        <TreatmentView
          treatmentRooms={treatmentRooms}
          waitingList={treatmentWaitingList}
          onNavigateBack={() => setCurrentView('dashboard')}
          onUpdateRooms={handleUpdateTreatmentRooms}
          onUpdateWaitingList={setTreatmentWaitingList}
          onMovePatientToPayment={(id) => handleMovePatientToPayment(id, 'treatment_room')}
          allPatients={allPatients}
          onUpdatePatientDefaultTreatments={updatePatientDefaultTreatments}
        />
      )}

      {currentView === 'acting' && (
        <ActingManagementView
            actingQueues={actingQueues}
            onQueueUpdate={setActingQueues}
            onNavigateBack={() => setCurrentView('dashboard')}
            treatmentRooms={treatmentRooms}
            allPatients={allPatients}
            onCompleteActing={handleCompleteActing}
            onAddActing={addActing}
            onDeleteActing={deleteActing}
            onEditActing={handleEditActing}
        />
      )}

      <Modal isOpen={modalType !== null} onClose={closeModal} title={modalTitle} wide={isModalWide}>
        {renderModalContent()}
      </Modal>

      {/* Patient Delete Confirmation Modal */}
      <Modal
          isOpen={patientIdToDelete !== null}
          onClose={handleCancelDelete}
          title="í™˜ì ì •ë³´ ì‚­ì œ í™•ì¸"
      >
          {patientToDeleteInfo && (
              <div className="text-center p-4">
                  <div className="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-red-100 mb-4">
                      <i className="fa-solid fa-triangle-exclamation text-2xl text-red-600"></i>
                  </div>
                  <h3 className="text-lg leading-6 font-semibold text-gray-900">
                      ì •ë§ë¡œ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?
                  </h3>
                  <div className="mt-2">
                      <p className="text-sm text-gray-600">
                          <span className="font-bold">{patientToDeleteInfo.name}</span>
                          ({patientToDeleteInfo.chartNumber || 'ì°¨íŠ¸ë²ˆí˜¸ ì—†ìŒ'}) ë‹˜ì˜ ì •ë³´ì™€ ê´€ë ¨ëœ ëª¨ë“  ì˜ˆì•½ ë° ëŒ€ê¸° ë‚´ì—­ì´ ì‚­ì œ ì²˜ë¦¬ë©ë‹ˆë‹¤.
                      </p>
                      <p className="text-sm font-bold text-gray-700 mt-2">
                          ì‚­ì œëœ ì •ë³´ëŠ” 'í™˜ê²½ ì„¤ì •'ì—ì„œ ë³µêµ¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
                      </p>
                  </div>
                  <div className="flex justify-center space-x-4 mt-6">
                      <button
                          type="button"
                          onClick={handleCancelDelete}
                          className="px-8 py-2 bg-gray-200 text-gray-800 font-semibold rounded-md hover:bg-gray-300 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-400"
                      >
                          ì·¨ì†Œ
                      </button>
                      <button
                          type="button"
                          onClick={handleConfirmDelete}
                          className="px-8 py-2 bg-red-600 text-white font-semibold rounded-md hover:bg-red-700 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500"
                      >
                          ì‚­ì œ
                      </button>
                  </div>
              </div>
          )}
      </Modal>

      {/* Bulk Add Result Modal */}
      <Modal
        isOpen={bulkAddResult !== null}
        onClose={() => setBulkAddResult(null)}
        title="í™˜ì ì¼ê´„ë“±ë¡ ê²°ê³¼"
      >
        {bulkAddResult && (
            <div className="space-y-4">
                <div className="flex justify-around text-center p-4 bg-gray-50 rounded-lg">
                    <div>
                        <p className="text-sm text-gray-500">ì‹ ê·œ ë“±ë¡</p>
                        <p className="text-3xl font-bold text-green-600">{bulkAddResult.new}ê±´</p>
                    </div>
                    <div>
                        <p className="text-sm text-gray-500">ì •ë³´ ì—…ë°ì´íŠ¸</p>
                        <p className="text-3xl font-bold text-blue-600">{bulkAddResult.updated}ê±´</p>
                    </div>
                    <div>
                        <p className="text-sm text-gray-500">ë“±ë¡ ì‹¤íŒ¨</p>
                        <p className="text-3xl font-bold text-red-600">{bulkAddResult.failures.length}ê±´</p>
                    </div>
                </div>
                
                {bulkAddResult.failures.length > 0 && (
                    <div className="pt-4 border-t">
                        <h4 className="font-semibold text-lg mb-2">ì‹¤íŒ¨ ë‚´ì—­</h4>
                        <div className="max-h-60 overflow-y-auto bg-white rounded-md border">
                            <table className="w-full text-sm text-left">
                                <thead className="text-xs text-gray-700 uppercase bg-gray-100 sticky top-0">
                                    <tr>
                                        <th className="px-4 py-2">ì´ë¦„</th>
                                        <th className="px-4 py-2">ì°¨íŠ¸ë²ˆí˜¸</th>
                                        <th className="px-4 py-2">ì‹¤íŒ¨ ì‚¬ìœ </th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {bulkAddResult.failures.map((fail, index) => (
                                        <tr key={index} className="bg-white border-b last:border-b-0">
                                            <td className="px-4 py-2 font-medium">{fail.name}</td>
                                            <td className="px-4 py-2">{fail.chartNumber}</td>
                                            <td className="px-4 py-2 text-red-700">{fail.reason}</td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    </div>
                )}
                
                <div className="flex justify-end pt-4 mt-4">
                    <button
                        onClick={() => setBulkAddResult(null)}
                        className="px-6 py-2 bg-clinic-primary text-white font-semibold rounded-md hover:bg-clinic-secondary"
                    >
                        í™•ì¸
                    </button>
                </div>
            </div>
        )}
      </Modal>
    </div>
  );
};

export default App;